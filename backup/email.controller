const pool = require("../db");
const nodemailer = require("nodemailer");
const { v4: uuidv4 } = require("uuid");
const threadId = uuidv4();
const { groupBy } = require("pg");

const getEmails = async (req, res) => {
  try {
      const userEmail = req.user.email;
      const folder = req.query.folder || '';
      const page = parseInt(req.query.page) || 1;
      const perPage = parseInt(req.query.perPage) || 20;

      // Validate pagination parameters
      if (page < 1 || perPage < 1 || isNaN(page) || isNaN(perPage)) {
          return res.status(400).json({ 
              error: "Invalid pagination parameters",
              details: {
                  page: "Must be a positive integer",
                  perPage: "Must be a positive integer"
              }
          });
      }

      if (!userEmail) {
          return res.status(400).json({ error: "Missing email in headers" });
      }

      // Get user ID
      const userResult = await pool.query(
          "SELECT id FROM users WHERE email = $1",
          [userEmail]
      );

      if (userResult.rows.length === 0) {
          return res.status(404).json({ error: "User not found" });
      }

      const userId = userResult.rows[0].id;

      // First get total count
      const countQuery = `
          SELECT COUNT(DISTINCT thread_id) 
          FROM mailboxes
          WHERE user_id = $1
          AND ($2 = '' OR folder = $2)
          AND ($3 = ANY(ARRAY[from_email, to_email]))
      `;
      const countResult = await pool.query(countQuery, [userId, folder, userEmail]);
      const totalCount = parseInt(countResult.rows[0].count);
      const totalPages = Math.ceil(totalCount / perPage);

      // Then fetch paginated results
      const emailsQuery = `
          SELECT sub.*
          FROM (
              SELECT DISTINCT ON (thread_id)
                  id, subject, body, from_email, to_email, 
                  created_at, thread_id, is_read, folder, 
                  message_id, is_draft
              FROM mailboxes
              WHERE user_id = $1
                  AND ($2 = '' OR folder = $2)
                  AND ($3 = ANY(ARRAY[from_email, to_email]))
              ORDER BY thread_id, created_at DESC
          ) sub
          ORDER BY sub.created_at DESC
          LIMIT $4 OFFSET $5;
      `;
      
      const offset = (page - 1) * perPage;
      const { rows } = await pool.query(emailsQuery, [
          userId, 
          folder, 
          userEmail,
          perPage,
          offset
      ]);

      res.status(200).json({ 
          emails: rows,
          pagination: {
              currentPage: page,
              perPage: perPage,
              totalCount: totalCount,
              totalPages: totalPages,
              hasNextPage: page < totalPages,
              hasPrevPage: page > 1
          }
      });
  } catch (error) {
      console.error("Error fetching emails:", error);
      res.status(500).json({ 
          error: "Internal server error",
          details: error.message 
      });
  }
};
  
  
  
  
  
  const getEmailsByThreadId = async (req, res) => {
    try {
      const userEmail = req.user.email;
      const { thread_id } = req.params; // passed as route param
        
      console.log(req.user, "USER")

      if (!userEmail) {
        return res.status(400).json({ error: "Missing email in headers" });
      }
  
      if (!thread_id) {
        return res.status(400).json({ error: "Missing thread_id parameter" });
      }
  
      // Get user ID
      const userResult = await pool.query(
        "SELECT id FROM users WHERE email = $1",
        [userEmail]
      );
  
      if (userResult.rows.length === 0) {
        return res.status(404).json({ error: "User not found" });
      }
  
      const userId = userResult.rows[0].id;
  
      // Fetch all emails from the same thread
      const { rows } = await pool.query(
        `SELECT * FROM mailboxes
         WHERE user_id = $1 AND thread_id = $2
         ORDER BY id ASC`,
        [userId, thread_id]
      );
  
      res.status(200).json({ threadEmails: rows });
  
    } catch (error) {
      console.error("Error fetching thread emails:", error);
      res.status(500).json({ error: "Internal server error" });
    }
  };
  
    




const sendEmail = async (req, res) => {
  const {
    to_email,
    cc = "",
    bcc = "",
    subject,
    body,
    plainText,
    is_reply = false,
    in_reply_to = null,
    is_draft=false
  } = req.body;

  try {
    // Lookup verified sender email from token
    const userResult = await pool.query(
      "SELECT email FROM users WHERE id = $1",
      [req.user.user_id]
    );
    const verifiedEmail = userResult.rows[0].email;
    const from_email = verifiedEmail;

    const messageId = `<${uuidv4()}@mail.abysfin.com>`;
    let threadId;

    if (is_reply && in_reply_to) {
      // Lookup original message to get thread_id
      const result = await pool.query(
        "SELECT thread_id FROM mailboxes WHERE message_id = $1",
        [in_reply_to]
      );

      if (result.rows.length === 0) {
        return res.status(400).json({ error: "Original message not found for reply." });
      }

      threadId = result.rows[0].thread_id;
    } else {
      // New message - generate new thread ID
      threadId = uuidv4();
    }

    // Setup mail transporter
    const transporter = nodemailer.createTransport({
      host: "localhost",
      port: 25,
      secure: false,
      tls: { rejectUnauthorized: false },
    });

    // Build headers
    const headers = {
      "Message-ID": messageId,
    };
    if (is_reply && in_reply_to) {
      headers["In-Reply-To"] = in_reply_to;
      headers["References"] = in_reply_to;
    }

    // Send mail
    await transporter.sendMail({
      from: from_email,
      to: to_email,
      cc: cc,
      bcc: bcc,
      subject,
      html: body,
      text: plainText,
      headers
    });

    // Save to DB
    await pool.query(
      `INSERT INTO mailboxes (
        user_id, folder, subject, body, plain_text,
        from_email, to_email, cc, bcc, is_read,
        thread_id, message_id, in_reply_to, is_draft
      )
      SELECT id, 'Sent', $1, $2, $3, $4, $5, $6, $7, true, $9, $10, $11, false
      FROM users WHERE email = $8`,
      [
        subject,
        body,
        plainText,
        from_email,
        to_email,
        cc,
        bcc,
        from_email,   // for SELECT
        threadId,
        messageId,
        in_reply_to
      ]
    );

    res.status(200).json({ message: "Email sent and saved to Sent folder.", user: req.user });

  } catch (err) {
    console.error("Email send error:", err);
    res.status(500).json({ error: "Failed to send email", details: err.message, user: req.user });
  }
};


const saveDraft = async (req, res) => {
  const {
    to_email = "",
    cc = "",
    bcc = "",
    subject = "",
    body = "",
    plainText = "",
    in_reply_to = null,
    message_id = null,  // Added message_id to check for existing draft
    thread_id = null   // Added thread_id for updating or creating new thread
  } = req.body;

  try {
    // Verify user and get their email
    const userResult = await pool.query(
      "SELECT email FROM users WHERE id = $1",
      [req.user.user_id]
    );
    
    if (!userResult.rows.length) {
      return res.status(401).json({ message: "Unauthenticated" });
    }

    const verifiedEmail = userResult.rows[0].email;
    const from_email = verifiedEmail;

    // Check if we have enough content to save a draft
    if (body === "" && subject === "" && to_email === "") {
      return res.status(400).json({ message: "Draft content is empty" });
    }

    // If message_id is provided, try to update existing draft
    if (message_id) {
      const updateResult = await pool.query(
        `UPDATE mailboxes 
         SET 
           subject = $1,
           body = $2,
           plain_text = $3,
           to_email = $4,
           cc = $5,
           bcc = $6,
           in_reply_to = $7,
           updated_at = NOW()
         WHERE 
           message_id = $8 
           AND user_id = $9 
           AND folder = 'Draft' 
           AND is_draft = true
         RETURNING id, thread_id`,
        [
          subject,
          body,
          plainText,
          to_email,
          cc,
          bcc,
          in_reply_to,
          message_id,
          req.user.user_id
        ]
      );

      if (updateResult.rowCount > 0) {
        return res.status(200).json({ 
          message: "Draft updated successfully",
          message_id: message_id,
          thread_id: updateResult.rows[0].thread_id
        });
      }
    }

    // If no message_id provided or draft not found, create new draft
    const newMessageId = `<${uuidv4()}@mail.abysfin.com>`;
    const newThreadId = thread_id || uuidv4();

    await pool.query(
      `INSERT INTO mailboxes (
        user_id, folder, subject, body, plain_text,
        from_email, to_email, cc, bcc, is_read,
        thread_id, message_id, in_reply_to, is_draft
      )
      SELECT id, 'Draft', $1, $2, $3, $4, $5, $6, $7, true, $9, $10, $11, true
      FROM users WHERE email = $8`,
      [
        subject,
        body,
        plainText,
        from_email,
        to_email,
        cc,
        bcc,
        from_email,
        newThreadId,
        newMessageId,
        in_reply_to
      ]
    );

    res.status(200).json({ 
      message: "Draft saved successfully",
      message_id: newMessageId,
      thread_id: newThreadId
    });

  } catch (err) {
    console.error("Error saving draft:", err);
    res.status(500).json({ message: "Something went wrong!", error: err.message });
  }
};




  


  const moveToTrash = async (req, res) => {
    const messageId = req.params.messageId;
    const userEmail = req.user.email;
  
    if (!messageId || !userEmail) {
      return res.status(400).json({ error: "Missing message ID or user information." });
    }
  
    try {
      const result = await pool.query(
        `UPDATE mailboxes 
         SET folder = 'Bin'
         WHERE message_id = $1 AND (from_email = $2 OR to_email = $2)`,
        [messageId, userEmail]
      );
  
      if (result.rowCount === 0) {
        return res.status(404).json({ error: "Email not found or unauthorized." });
      }
  
      res.status(200).json({ message: "Email moved to Trash/Bin successfully." });
    } catch (error) {
      console.error("Error moving email to trash:", error);
      res.status(500).json({ error: "Failed to move email to Trash." });
    }
  };
  

  const deleteEmail = async (req, res) => {
    const messageId = req.params.messageId;
    const userEmail = req.user.email; // assuming you're using JWT middleware that sets req.user
  
    if (!messageId || !userEmail) {
      return res.status(400).json({ error: "Missing message ID or user info" });
    }
  
    try {
      // Optional: Soft delete - move to trash/bin folder instead
      // await pool.query(
      //   "UPDATE mailboxes SET folder = 'Bin' WHERE message_id = $1 AND from_email = $2",
      //   [messageId, userEmail]
      // );
  
      // Hard delete:
      const result = await pool.query(
        "DELETE FROM mailboxes WHERE message_id = $1 AND from_email = $2",
        [messageId, userEmail]
      );
  
      if (result.rowCount === 0) {
        return res.status(404).json({ error: "Email not found or unauthorized" });
      }
  
      res.status(200).json({ message: "Email deleted successfully" });
    } catch (error) {
      console.error("Error deleting email:", error);
      res.status(500).json({ error: "Failed to delete email" });
    }
  };


  const setEmailIsRead = async (req, res) => {
    const { is_read } = req.body;
    const { thread_id } = req.params;
        // Lookup verified sender email
        const userResult = await pool.query("SELECT email FROM users WHERE id = $1", [req.user.user_id]);
        const verifiedEmail = userResult.rows[0].email;
        const userEmail = verifiedEmail;
  
    if (!thread_id) {
      return res.status(400).json({ error: "Missing thread_id parameter." });
    }
  
    if (typeof is_read !== 'boolean') {
      return res.status(400).json({ error: "'is_read' must be true or false." });
    }
  
    try {
      const result = await pool.query(
        `UPDATE mailboxes 
         SET is_read = $1
         WHERE thread_id = $2
           AND (to_email = $3 OR from_email = $3)
           AND is_read != $1`, // Only update if value needs to change
        [is_read, thread_id, userEmail]
      );
  
      if (result.rowCount === 0) {
        return res.status(404).json({ error: "No matching emails found or already updated." });
      }
  
      res.status(200).json({
        message: `All emails in thread marked as ${is_read ? 'read' : 'unread'}.`,
        updatedCount: result.rowCount
      });
    } catch (error) {
      console.error("Error updating thread read status:", error);
      res.status(500).json({ error: "Failed to update email read status." });
    }
  };
  
  
  
  const setEmailStarred = async (req, res) => {
    const messageId = req.params.messageId;
    const { is_starred } = req.body;
    const userEmail = req.user.email; // assuming JWT middleware sets req.user
  
    if (typeof is_starred !== 'boolean') {
      return res.status(400).json({ error: "'is_starred' must be true or false" });
    }
  
    try {
      const result = await pool.query(
        `UPDATE mailboxes 
         SET is_starred = $1 
         WHERE message_id = $2 AND (to_email = $3 OR from_email = $3)`,
        [is_starred, messageId, userEmail]
      );
  
      if (result.rowCount === 0) {
        return res.status(404).json({ error: "Email not found or unauthorized." });
      }
  
      res.status(200).json({ message: `Email ${is_starred ? 'starred' : 'unstarred'} successfully.` });
    } catch (error) {
      console.error("Error updating star status:", error);
      res.status(500).json({ error: "Failed to update email star status." });
    }
  };
  
  

module.exports = {getEmails, sendEmail, getEmailsByThreadId, moveToTrash, deleteEmail, setEmailIsRead, setEmailStarred, saveDraft};